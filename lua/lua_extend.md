Lua 扩展

lua 最强大的地方在于其可以将其他语言作为库的形式为 Lua 所调用。

关键点
---------------

###为什么是栈

* Lua 的gc        C 的手动内存管理
* Lua 的动态语言   C 是静态语言

对于上面两者之间的差异通过栈能够很好地解决。

###栈结构

栈顶为 -1 栈底为 1

###测试栈的变化

215 代码加上递归版本的 StackDump()

栈不是全局性的结构，每个函数都有自己的局部私有栈。当调用一个函数时，第一个参数的索引就是1,即栈底。


C API
---------------
1. API 中的大多数函数不会检测参数的正确性，所有必须保证传参的合法性。如果传入错误的参数，将出现 segmentation fault 或类似错误。
2. 字符串不以零结尾。
3. Lua 不会持有外部字符串指针，而是生成一个副本，或复用现有内容。确保在函数返回后立即释放或修改字符串不会出现问题。



Lua 调用 C （库代码）
---------------

### C 文件
编写static函数
* 从栈中获取参数
* 参数检查
* 处理
* 返回结果参数个数

static const luaL_Reg mylib[] = {
	{"test",func},
	{NULL,NULL}
};

int luaopen_mylib(lua_State *L)
{
 	luaL_register()
 	return 1;
}


###Lua 文件
* 加载库 require"mylib"
* 调用函数
* 检查参数返回？


####协调
程序员必须自己确保 Lua 文件当中的参数必须与 C 文件中的参数一致。

###错误处理
* lua_error() 会清理所有 Lua 要清理的内容。

###编写 C 模块的技巧
TODO



C 调用 Lua（应用程序代码）
---------------

### C 文件
* lua_State *L = luaL_newstate()
* luaL_openlib(L)
* 检查参数
* 将参数压入栈
* lua_pcall(L,0,0,0) LUA_ERRMEM LUA_ERRERR
* 获取结果
* lua_close(L)
* 返回结果

###Lua 文件
实现函数。

####协调
程序员必须自己确保 Lua 文件当中的参数必须与 C 文件中的参数一致。

###错误处理
必须提供一种捕获错误的方式：

1. 设置自己的lua_atpanic()， 利用 longjmp 和 setjmp
2. lua_pcall()  lua_cpcall()



 
要点
1. 参数检查（类型检查）
2. 错误处理
3. 异常处理
4. 内存分配
5. 检查栈有足够空间 lua_checkstack()


lua.h -- 基础函数，保持原子性和正交性
lualib.h -- 辅助库，解决具体任务
没有任何全局变量，所有的状态都保存在lua_State，所有 C API都要传入一个指向该结构的指针。可重入的特性，使之稍加修改就可以用于多线程。



